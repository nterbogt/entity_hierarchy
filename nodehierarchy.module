<?php

/**
 * @file
 *
 * A module to make nodes hierarchical.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity;
use Drupal\Core\Render\Element;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\Core\Entity\EntityInterface;

/**
 * Implements @see hook_help().
 */
function nodehierarchy_help($route_name, RouteMatchInterface $route_match) {
  // TODO: improve help text
  switch ($route_name) {
    case 'help.page.nodehierarchy':
      return t('A module to make nodes hierarchical.');
  }
}

/**
 * Implements @see hook_form_BASE_FORM_ID_alter() for node_form().
 *
 * Adds a vertical tab to the node form allowing a hierarchy parent to be
 * selected or deleted. Here we're doing some permission checking, then
 * presenting the form using the HierarchyManager class. We then use an
 * #entity_builders callback function to save the form data to the node object.
 *
 * @see HierarchyManagerInterface::addHierarchyFormElement
 * @see nodehierarchy_node_builder
 */
function nodehierarchy_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // TODO: nodehierarchy_set_breadcrumbs($node, TRUE);
  // Load the node object associated with this form
  $node = $form_state->getFormObject()->getEntity();
  $account = \Drupal::currentUser();

  /** @var \Drupal\nodehierarchy\HierarchyManager $hierarchy_manager */
  $hierarchy_manager = \Drupal::service('nodehierarchy.manager');

  // If this node type can be a child.
  // TODO: Probably should be doing access checking using a class like
  // EntityAccessControlHandler::access or more at the route/level
  /** @see \Drupal\Core\Entity\EntityAccessControlHandler::access */
  if ( ($hierarchy_manager->hierarchyCanBeChild($node)) || ($hierarchy_manager->hierarchyCanBeParent($node)) ) {
    // if the current user can edit the current node's hierarchy settings (or create new children)
    $uid = $node->getOwnerId();
    $can_set_parent = $account->hasPermission('edit all node parents') ||
      ($node->isNew() && $account->hasPermission('create child nodes')) ||
      ($uid == $account->getAccount()->id() && $account->hasPermission('edit own node parents'));

    // Only show the form is the user has permission
    if ($can_set_parent) {
      $collapsed = TRUE;  // Todo: fix (check if a parent is already set)
      $form = $hierarchy_manager->addHierarchyFormElement($form, $form_state, $node, $account, $collapsed);
      // Form API entity_builders callback; see https://www.drupal.org/node/2420295
      $form['#entity_builders'][] = 'nodehierarchy_node_builder';
    }
  }
}

/**
 * Entity form builder adds the hierarchy information to the node object. More
 * officially, this builds an updated entity object based upon the submitted
 * form values.
 *
 * This function is called from the #entity_builders callback.
 *
 * @see nodehierarchy_form_node_form_alter
 * @see EntityForm::buildEntity
 *
 * As per https://www.drupal.org/node/2420295, an entity field may be better
 * suited to this task.
 * @see \Drupal\Core\Entity\ContentEntityBase
 * @see core/lib/Drupal/Core/Entity/ContentEntityBase.php
 */
function nodehierarchy_node_builder($entity_type, NodeInterface $node, &$form, FormStateInterface $form_state) {
  $node->nodehierarchy_parents = $form_state->getValue('nodehierarchy_parents');
}

/**
 * Implements @see hook_entity_type_build().
 *
 * Here we're adding a form controller class for a custom node form without
 * overriding the default node form.
 *
 * More specifically, we're adding a children form to a tab named children.
 * This routing information for this tab is set in the .routing.yml file, and
 * the .links.task.yml file.
 *
 * @see \Drupal\nodehierarchy\Form\NodehierarchyChildrenForm
 */
function nodehierarchy_entity_type_build(array &$entity_types) {
  /** @type $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
  $entity_types['node']
    ->setFormClass('nodehierarchy_children', 'Drupal\nodehierarchy\Form\NodehierarchyChildrenForm')
    ->setLinkTemplate('nodehierarchy-children-form', '/node/{node}/children');
}

/**
 * Implements @see hook_form_alter().
 *
 * Right now, we're defining functionality for the node delete form. Most likely
 * this functionality will all me moved in the near future.
 */
function nodehierarchy_form_alter(&$form, FormStateInterface $form_state, $form_id) {

  // Does the form ID end with '_node_delete_form' ?
  endsWith($form_id,"_node_delete_form") ? $node_delete_type = $form_id : $node_delete_type = '';
  // Todo: fix (we set the value incorrectly on purpose so this id is never called.
  $node_delete_type = 'abcdefg';

  switch ($form_id) {
    case $node_delete_type:
      // TODO: Fix the descendant count code to deal with multiparent situations.
      if ($count = _nodehierarchy_get_children_count($form['nid']['#value'])) {
        $items = array();
        foreach (_nodehierarchy_get_children_menu_links($form['nid']['#value'], 10) as $child) {
          $items[] = /*check_plain*/($child['link_title']);
        }
        if ($count > 10) {
          $items[] = $this->l(t('See all !count children', array('!count' => $count)), 'node/' . $form['nid']['#value'] . '/children');
        }
        $list = /*theme('item_list',*/ array('items' => $items)/*)*/;
        $description = \Drupal::translation()->formatPlural($count,
          'This node has @count child. Check this box to delete it and all of its descendants as well.',
          'This node has @count children. Check this box to delete them and all of their descendants as well.' );
        $description .= t('<p>These children and their decendants will be deleted:!list<p>', array('!list' => $list));
        $form['nodehierarchy_delete_children'] = array(
          '#type' => 'checkbox',
          '#title' => t('Delete descendants'),
          '#description' => $description,
        );
        array_unshift($form['#submit'], 'nodehierarchy_node_delete_submit');
        $form['actions']['#weight'] = 1;
      }
      break;
  }
}

/**
 * Implements @see hook_form_FORM_ID_alter().
 *
 * Here we are altering the node type edit form to include hierarchy settings,
 * such as setting which content types should support one or more child content
 * types.
 *
 * @see HierarchyManagerInterface::hierarchyGetNodeTypeSettingsForm
 */
function nodehierarchy_form_node_type_edit_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\nodehierarchy\HierarchyManager $hierarchy_manager */
  $hierarchy_manager = \Drupal::service('nodehierarchy.manager');
  // TODO: check if there's any reason we're not including the base $form
  // declaration in the class method.
  $type = $form['type']['#default_value'];  // The content type

  $form['hierarchy'] = array(
    '#type' => 'details',
    '#group' => 'additional_settings',
    '#title' => t('Node Hierarchy'),
    '#weight' => 10,
  );

  // Right now, we add this js to all admin pages using hook_page_attachments; see below.
  // $form['#attached']['library'][] = nodehierarchy/nodehierarchy.nodetypeform;

  $form['hierarchy'] += $hierarchy_manager->hierarchyGetNodeTypeSettingsForm($type);
}

/**
 * Implements @see hook_ENTITY_TYPE_insert() for node entities.
 *
 * This function will be called whenever a new node is created. We will write
 * the hierarchy information to the database if a parent is set on the node
 * add form.
 *
 * @see HierarchyManagerInterface::hierarchySaveNode
 */
function nodehierarchy_node_insert(NodeInterface $node) {
  /** @var \Drupal\nodehierarchy\HierarchyManager $hierarchy_manager */
  $hierarchy_manager = \Drupal::service('nodehierarchy.manager');
  // TODO: check if we really need a permission check here. (Don't even show the form if no permission.)
  $user = \Drupal::currentUser();
  $uid = $user->id();
  $node_uid = $node->getOwnerId();
  if ($user->hasPermission('edit all node parents') || ($node_uid == $uid && $user->hasPermission('edit own node parents'))) {
    $hierarchy_manager->hierarchySaveNode($node);
  }
}

/**
 * Implements @see hook_ENTITY_TYPE_update().
 *
 * This function will be called whenever a node is updated. We will write
 * the hierarchy information to the database if a parent is set on the node
 * edit form or delete the parent if a checkbox is selected.
 *
 * @see HierarchyManagerInterface::hierarchySaveNode
 */
function nodehierarchy_node_update(EntityInterface $node) {
  $hierarchy_manager = \Drupal::service('nodehierarchy.manager');
  $hierarchy_manager->hierarchySaveNode($node);
}

/**
 * Implements @see hook_node_prepare_form().
 *
 * We are loading the hierarchy parents for a given node id, and adding it to
 * the node object for later processing in
 * HierarchyManagerInterface::addHierarchyFormElement, which is called in
 * nodehierarchy_form_node_form_alter().
 *
 * @see nodehierarchy_form_node_form_alter
 * @see HierarchyManagerInterface::addHierarchyFormElement
 * @see HierarchyManagerInterface::hierarchyDefaultRecord
 */
function nodehierarchy_node_prepare_form(NodeInterface $node) {
  /** @var \Drupal\nodehierarchy\HierarchyManager $hierarchy_manager */
  $hierarchy_manager = \Drupal::service('nodehierarchy.manager');
  /** @var \Drupal\nodehierarchy\HierarchyOutlineStorage $hierarchy_storage */
  $hierarchy_storage = \Drupal::service('nodehierarchy.outline_storage');

  // Load the parents if that hasn't been done before.
  $nid = $node->id();
  if (!isset($node->nodehierarchy_parents) && !empty($nid)) {
    $node->nodehierarchy_parents = $hierarchy_storage->hierarchyGetParents($node->id());
  }
  // Cannot use module_invoke_all because it doesn't support references.
  foreach (\Drupal::moduleHandler()->getImplementations('nodehierarchy_default_parents') as $module) {
    $function = $module . '_nodehierarchy_default_parents';
    $function($node);
  }

  if ( ($hierarchy_manager->hierarchyCanBeChild($node)) || ($hierarchy_manager->hierarchyCanBeParent($node)) ) {
    if (!isset($node->nodehierarchy_parents) || empty($node->nodehierarchy_parents)) {
      // Create a default nodehierarchy object.
      $nid = empty($nid) ? null : $node->id();
      $parent = $hierarchy_manager->hierarchyDefaultRecord($nid, 0);

      // Set the type default if there is one.
      if (empty($nid)) {
        $config = \Drupal::config('nodehierarchy.settings');
//        $default = $config->get('nh_defaultparent_'.$node->getEntityType());//variable_get('nh_defaultparent_' . $node->type, 0);
        // Get the parent node id from passed in from the get params.
        $pnid = !empty($_GET['parent']) ? (int) $_GET['parent'] : $default;
        // Get the parent from the get string. User must have update perms for parent unless it is the default.
        $account = \Drupal::currentUser();
        if ($pnid && $parent_node = Node::load($pnid)) {
          if (($hierarchy_manager->hierarchyCanBeParent($node)) && ($account->hasPermission('create child of any parent')
              || $node->access("update") || $parent_node->id() == $default)) {
            $parent->pnid = $pnid;
          }
        }
      }
      $node->nodehierarchy_parents[] = $parent;
    }
  }
}

/**
 * Implements @see hook_page_attachments().
 *
 * Right now, we're attaching an un-used jS file to all admin pages. Need to
 * re-visit this and only load on the appropriate pages and/or forms.
 */
function nodehierarchy_page_attachments(&$page) {
  // This returns TRUE for admin paths.
  if (\Drupal::service('router.admin_context')->isAdminRoute()) {
    // Load nodehierarchy.js on admin pages
    $page['#attached']['library'][] = 'nodehierarchy/nodehierarchy.nodetypeform';
  }
}

/**
 * Implements @see hook_ENTITY_TYPE_load() for node entities.
 *
 * Don't think this function is being used right now, so will investigate and
 * either delete or improve docs.
 */
function nodehierarchy_node_load($nodes) {
// TODO: Should we be loading the parent selection here instead using the code below?

  $nids = array_keys($nodes);
  /** @var \Drupal\nodehierarchy\HierarchyOutlineStorage $hierarchy_storage */
  $hierarchy_storage = \Drupal::service('nodehierarchy.outline_storage');
  $pids = $hierarchy_storage->loadHierarchies($nids);
  foreach ($pids as $pid) {
    $title = Node::load($pid)->getTitle();
    $nodes[$pid['nid']]->nodehierarchy_parents = $pid;
  }
}

/**
 * Helper functions for strings to determine if a string starts or ends with a
 * substring.
 */
function startsWith($haystack, $needle) {
  // search backwards starting from haystack length characters from the end
  return $needle === "" || strrpos($haystack, $needle, -strlen($haystack)) !== FALSE;
}
function endsWith($haystack, $needle) {
  // search forward starting from end minus needle length characters
  return $needle === "" || strpos($haystack, $needle, strlen($haystack) - strlen($needle)) !== FALSE;
}