<?php

/**
 * @file
 *
 * A module to make nodes hierarchical.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity;
use Drupal\Core\Render\Element;
use Drupal\node\Entity\Node;
use Drupal\node\NodeInterface;
use Drupal\Component\Utility\Unicode;
use Drupal\nodehierarchy\HierarchyManager;
use Drupal\node\NodeTypeInterface;
use Drupal\Core\Language\LanguageInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Extension\Extension;
use Drupal\nodehierarchy\HierarchyManagerInterface;
use Drupal\Component\Utility\String;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Url;

/**
 * Implements hook_help().
 */
function nodehierarchy_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.nodehierarchy':
      return t('A module to make nodes hierarchical.');
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form().
 *
 * Adds the hierarchy form element to the node form.
 */
function nodehierarchy_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // TODO: nodehierarchy_set_breadcrumbs($node, TRUE);
  // Load the node object associated with this form
  $node = $form_state->getFormObject()->getEntity();
  $account = \Drupal::currentUser();

  $hierarchy_manager = \Drupal::service('nodehierarchy.manager');

  // If this node type can be a child.
  if ( ($hierarchy_manager->hierarchyCanBeChild($node)) || ($hierarchy_manager->hierarchyCanBeParent($node)) ) {
    // if the current user can edit the current node's hierarchy settings (or create new children)
    $uid = $node->getOwnerId();
    $can_set_parent = $account->hasPermission('edit all node parents') ||
      ($node->isNew() && $account->hasPermission('create child nodes')) ||
      ($uid == $account->getAccount()->id() && $account->hasPermission('edit own node parents'));

    // Only show the form is the user has permission
    if ($can_set_parent) {
      $collapsed = TRUE;  // Todo: fix
      $form = $hierarchy_manager->addFormElements($form, $form_state, $node, $account, $collapsed);
      $form = $hierarchy_manager->addHierarchyFormElement($form, $form_state, $node, $account, $collapsed);
    }
  }
}


/**
 * Implements hook_ENTITY_TYPE_insert() for node entities.
 *
 *  {@inheritdoc}
 */
function nodehierarchy_node_insert(NodeInterface $node) {
  $hierarchy_manager = \Drupal::service('nodehierarchy.manager');
  $user = \Drupal::currentUser();
  $uid = $user->id();
  $node_uid = $node->getOwnerId();
  if ($user->hasPermission('edit all node parents') || ($node_uid == $uid && $user->hasPermission('edit own node parents'))) {
    $hierarchy_manager->hierarchySaveNode($node);
  }
}


/**
 * Implements hook_node_prepare_form().
 *
 * {@inheritdoc}
 */
function nodehierarchy_node_prepare_form(NodeInterface $node) {

  $hierarchy_manager = \Drupal::service('nodehierarchy.manager');
  $hierarchy_storage = \Drupal::service('nodehierarchy.outline_storage');

  // Load the parents if that hasn't been done before.
  $nid = $node->id();
  if (!isset($node->nodehierarchy_parents) && !empty($nid)) {
    $node->nodehierarchy_parents = $hierarchy_storage->hierarchyGetParents($node->id());
  }
  // Cannot use module_invoke_all because it doesn't support references.
  foreach (\Drupal::moduleHandler()->getImplementations('nodehierarchy_default_parents') as $module) {
    $function = $module . '_nodehierarchy_default_parents';
    $function($node);
  }


  if ( ($hierarchy_manager->hierarchyCanBeChild($node)) || ($hierarchy_manager->hierarchyCanBeParent($node)) ) {
    if (!isset($node->nodehierarchy_parents) || empty($node->nodehierarchy_parents)) {
      // Create a default nodeheirarchy object.
      $nid = empty($nid) ? null : $node->id();
      $parent = $hierarchy_manager->hierarchyDefaultRecord($nid, 0);

      // Set the type default if there is one.
      if (empty($nid)) {
        $config = \Drupal::config('nodehierarchy.settings');
        $default = $config->get('nh_defaultparent_'.$node->getEntityType());//variable_get('nh_defaultparent_' . $node->type, 0);
        // Get the parent node id from passed in from the get params.
        $pnid = !empty($_GET['parent']) ? (int) $_GET['parent'] : $default;
        // Get the parent from the get string. User must have update perms for parent unless it is the default.
        $account = \Drupal::currentUser();
        if ($pnid && $parent_node = node_load($pnid)) {
          if (($hierarchy_manager->hierarchyCanBeParent($node)) && ($account->hasPermission('create child of any parent')
              || $node->access("update") || $parent_node->id() == $default)) {
            $parent->pnid = $pnid;
          }
        }
      }
      $node->nodehierarchy_parents[] = $parent;
    }
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * So we don't see preview or delete buttons for hierarchy.
 */
function nodehierarchy_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Check if the form id string ends with "_node_form"
  endsWith($form_id,"_node_form") || endsWith($form_id,"_node_edit_form") ? $node_type = $form_id : $node_type = '';
  endsWith($form_id,"_node_delete_form") ? $node_delete_type = $form_id : $node_delete_type = '';
  $type = $form['type']['#default_value'];  // The type of node

  switch ($form_id) {
    case 'node_type_edit_form':
      //$type = $form['old_type']['#value'];

      $form['nodehierarchy'] = array(
        '#type' => 'details',
        '#group' => 'additional_settings',
        '#title' => t('Node Hierarchy'),
        '#weight' => 10,
      );

      // $form['#attached']['library'][] = nodehierarchy/nodehierarchy.nodetypeform;
      // Right now, we add this js to all admin pages using hook_page_attachments; see below.

      $form['nodehierarchy'] += _nodehierarchy_get_node_type_settings_form($type);

      // TODO: right now the values are not being saved for the node type form
      break;
    case $node_delete_type:
      // TODO: Fix the descendant count code to deal with multiparent situations.
      if ($count = _nodehierarchy_get_children_count($form['nid']['#value'])) {
        $items = array();
        foreach (_nodehierarchy_get_children_menu_links($form['nid']['#value'], 10) as $child) {
          $items[] = /*check_plain*/($child['link_title']);
        }
        if ($count > 10) {
          $items[] = $this->l(t('See all !count children', array('!count' => $count)), 'node/' . $form['nid']['#value'] . '/children');
        }
        $list = /*theme('item_list',*/ array('items' => $items)/*)*/;
        $description = \Drupal::translation()->formatPlural($count,
          'This node has @count child. Check this box to delete it and all of its descendants as well.',
          'This node has @count children. Check this box to delete them and all of their descendants as well.' );
        $description .= t('<p>These children and their decendants will be deleted:!list<p>', array('!list' => $list));
        $form['nodehierarchy_delete_children'] = array(
          '#type' => 'checkbox',
          '#title' => t('Delete descendants'),
          '#description' => $description,
        );
        array_unshift($form['#submit'], 'nodehierarchy_node_delete_submit');
        $form['actions']['#weight'] = 1;
      }
      break;
  }
}

/**
 * Implements hook_page_attachments().
 */
function nodehierarchy_page_attachments(&$page) {
  // This returns TRUE for admin paths.
  if (\Drupal::service('router.admin_context')->isAdminRoute()) {
    // Load nodehierarchy.js on admin pages
    $page['#attached']['library'][] = 'nodehierarchy/nodehierarchy.nodetypeform';
  }
}

/**
 * Get the nodehierarchy setting form for a particular node type.
 */
function _nodehierarchy_get_node_type_settings_form($key, $append_key = FALSE) {
  $config =  \Drupal::config('nodehierarchy.settings');

  $form['nh_allowchild'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Allowed child node types'),
    '#options' => node_type_get_names(),
    '#default_value' => $config->get('nh_allowchild_'.$key),
    '#description' => t('Node types which can be created as child nodes of this node type.'),
  );

  //$form['nh_defaultparent'] = _nodehierarchy_get_parent_selector($key, $config->get('nh_defaultparent_'.$key));
  // TODO: add default parent support later
  //$form['nh_defaultparent']['#title'] = t('Default Parent');

  $form['nh_createmenu'] = array(
    '#type' => 'radios',
    '#title' => t('Show item in menu'),
    '#default_value' => $config->get('nh_createmenu_'.$key), //variable_get('nh_createmenu_' . $key, 'optional_no'),
    '#options' => array(
      'never' => t('Never'),
      'optional_no' => t('Optional - default to no'),
      'optional_yes' => t('Optional - default to yes'),
      'always' => t('Always'),
    ),
    '#description' => t("Users must have the 'administer menu' or 'customize nodehierarchy menus' permission to override default options."),
  );
  $form['nh_multiple'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow multiple parents'),
    '#default_value' => $config->get('nh_multiple_'.$key),
    '#description' => t('Can nodes of this type have multiple parents?.'),
  );

  //$form += module_invoke_all('nodehierarchy_node_type_settings_form', $key);

  // If we need to append the node type key to the form elements, we do so.
  if ($append_key) {
    // Appending the key does not work recursively, so fieldsets etc. are not supported.
    $children = \Drupal\Core\Render\Element::children($form);
    foreach ($children as $form_key) {
      $form[$form_key . '_' . $key] = $form[$form_key];
      unset($form[$form_key]);
    }
  }
  return $form;
}

/**
 * Get the title of the given item to display in a pulldown.
 */
function _nodehierarchy_parent_option_title($item) {
  return str_repeat('--', $item->depth - 1) . ' ' . Unicode::truncate($item->title, 60, TRUE, FALSE);
}

/**
 * Return a list of menu items that are valid possible parents for the given node.
 */
function _nodehierarchy_parent_options($child_type, $exclude = NULL) {
  static $options = array();

  // If these options have already been generated, then return that saved version.
  if (isset($options[$child_type][$exclude])) {
    return $options[$child_type][$exclude];
  }

  $result = array();
  // Flatten tree to a list of options.
  $parent_types = \Drupal::service('nodehierarchy.manager')->hierarchyGetAllowedParentTypes($child_type);
//  dsm($parent_types);
//  $out = nodehierarchy_tree_data($result, $exclude, $parent_types);
//  dsm($out);

  // Static caching to prevent these options being built more than once.
//  $options[$child_type][$exclude] = $out;
//  return $out;
  return $parent_types;
}



/**
 * Build the data representing a menu tree.
 *
 * @param $result
 *   The database result.
 * @param $parents
 *   An array of the plid values that represent the path from the current page
 *   to the root of the menu tree.
 * @param $depth
 *   The depth of the current menu tree.
 * @return
 *   See menu_tree_page_data for a description of the data structure.
 */
function nodehierarchy_tree_data($result = NULL, $exclude = NULL, $allowed_types, $depth = 1) {
  list(, $tree) = _nodehierarchy_tree_data($result, $exclude, $allowed_types, $depth);
  return $tree;
}

/**
 * Recursive helper function to build the data representing a menu tree.
 *
 * The function is a bit complex because the rendering of an item depends on
 * the next menu item. So we are always rendering the element previously
 * processed not the current one.
 */
function _nodehierarchy_tree_data($result, $exclude = NULL, $allowed_types, $depth, $previous_element = array()) {
  $remnant = NULL;
  $tree = array();
  $enabled_tree = TRUE;
  $exclude = NULL;

  foreach ($result as $item) {
    if ($exclude !== $item['nid']) {
      $item['disabled'] = in_array($item['type'], $allowed_types) ? FALSE : TRUE;
//      $item['disabled'] = $item['disabled'] || (!node_access('update', $item) && !user_access('create child of any parent'));
      $enabled_tree = $enabled_tree || empty($item['disabled']) || (isset($previous_element['disabled']) && empty($previous_element['disabled']));

      // The current item is the first in a new submenu.
      if ($item['depth'] > $depth) {
        // _menu_tree returns an item and the menu tree structure.
        list($item, $below) = _nodehierarchy_tree_data($result, $exclude, $allowed_types, $item['depth'], $item);
        if ($previous_element && ($below || !$previous_element['disabled'])) {
          $tree[_nodehierarchy_get_parent_selector_value($previous_element)] = $previous_element;
        }
        $tree += $below;

        // We need to fall back one level.
        if (!isset($item) || $item['depth'] < $depth) {
          return $enabled_tree ? array($item, $tree) : array($item, array());
        }
        // This will be the link to be output in the next iteration.
        $previous_element = $item;
      }
      // We are at the same depth, so we use the previous element.
      elseif ($item['depth'] == $depth) {
        if ($previous_element && !$previous_element['disabled']) {
          // Only the first time.
          $tree[_nodehierarchy_get_parent_selector_value($previous_element)] = $previous_element;
        }
        // This will be the link to be output in the next iteration.
        $previous_element = $item;
      }
      // The submenu ended with the previous item, so pass back the current item.
      else {
        $remnant = $item;
        break;
      }
    }
  }
  if ($previous_element && !$previous_element['disabled']) {
    // We have one more link dangling.
    $tree[_nodehierarchy_get_parent_selector_value($previous_element)] = $previous_element;
  }
  return $enabled_tree ? array($remnant, $tree) : array($remnant, array());
}


/* Helper Functions for strings */
function startsWith($haystack, $needle) {
  // search backwards starting from haystack length characters from the end
  return $needle === "" || strrpos($haystack, $needle, -strlen($haystack)) !== FALSE;
}
function endsWith($haystack, $needle) {
  // search forward starting from end minus needle length characters
  return $needle === "" || strpos($haystack, $needle, strlen($haystack) - strlen($needle)) !== FALSE;
}
